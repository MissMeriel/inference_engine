/* prob.cup */
 
/***** Command Line build instructions (as implemented in Makefile)
 in this (src) directory:
 java -jar java-cup-11a.jar  PA0.cup
 javac -classpath .:java-cup-11a-runtime.jar -d . parser.java sym.java Yylex.java
    
*****/

/***** Run instructions
 in this (src) directory:
 java -classpath .:java-cup-11a-runtime.jar parser ../infile

*****/

import java.io.FileInputStream;
import java.util.function.Predicate;
import java_cup.runtime.*;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;
import mjparser.*;

parser code {:

    public PrintWriter out; 
    
    public String programName;

    public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
        //System.out.println("cur_SymbolValue: "+ cur_SymbolValue.value);
								report_fatal_error("Fatal syntax error", cur_SymbolValue);
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
        Symbol sym = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
        throw new mjparser.ParseException("Fatal parsing error", 
                                          tok.line, tok.pos);
    }
    
    public void report_error(String message, Object info) {
        Symbol sym = (Symbol)info;
        mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
								System.out.println("sym null? "+(sym == null));
								System.out.println("sym.sym: "+sym.sym);
								System.err.println("tok null? "+ (tok == null));
								System.err.println("tok.lexeme: "+ tok.lexeme);
        System.err.println("[" + tok.line + "," + tok.pos + "] "); 
        System.err.println( message + " at " + tok.toString() );
}
:}

terminal GIVENS;
terminal EVENTS;
terminal VARIABLE;
terminal DELTA_VARIABLE;
terminal Integer NUMBER;
terminal LT, LTEQ, GT, GTEQ;
terminal SEMI;
terminal COMMA;
terminal COMMENT;
non terminal program;
non terminal vars;
non terminal var;
non terminal stmts;
non terminal stmt;
non terminal RawType type;
non terminal Predicate exp;
non terminal Double int;
non terminal String variable;
non terminal comments;

precedence left LT, LTEQ, GT, GTEQ;

program	::=	
	GIVENS vars EVENTS vars
	;

vars ::=
		vars var
		| var
		;
	
var ::=
		variable:v COMMA type:t
		| variable:v COMMA type:t COMMA stmts
		;
	
stmts   ::=
    stmts COMMA stmt
    |	stmt
				;

stmt	::=
    exp:e		{: System.out.println("exp "+ e.toString()); :}
    ;

exp ::=            
				var:a LT:op int:b       {: System.out.println(a.toString() + " < " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d < b.doubleValue();}; :}
				|	var:a LTEQ:op int:b			{: System.out.println(a.toString() +" <= " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d <= b.doubleValue();}; :}
				|	var:a GT:op int:b			  {: System.out.println(a.toString() +" > " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d > b.doubleValue();}; :}
				|	var:a GTEQ:op int:b			{: System.out.println(a.toString() +" >= " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d >= b.doubleValue();}; :}
				| NUMBER:n              {: RESULT = (Predicate<Double>) (Double d) -> {return Math.abs(d-n.doubleValue())<1;}; :}
    ;

int ::=
	NUMBER:n	{: RESULT = n.doubleValue(); :}
	;

variable ::=
	VARIABLE:v {: RESULT = v.toString(); :}
	;
