/* prob.cup */
 
/***** Command Line build instructions (as implemented in Makefile)
 in this (src) directory:
 java -jar java-cup-11a.jar  PA0.cup
 javac -classpath .:java-cup-11a-runtime.jar -d . parser.java sym.java Yylex.java
    
*****/

/***** Run instructions
 in this (src) directory:
 java -classpath .:java-cup-11a-runtime.jar parser ../infile

*****/
package mjparser;

import java_cup.runtime.*;
import java.io.FileInputStream;
import java.util.function.Predicate;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;

import inference_engine.RawType;

parser code {:
    public static void main(String args[]) throws Exception {
        new parser(new Yylex(new FileInputStream(args[0]))).parse();
    }
				
				public PrintWriter out; 
    
					public String programName;
	
					public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
									//System.out.println("cur_SymbolValue: "+ cur_SymbolValue.value);
									report_fatal_error("Fatal syntax error", cur_SymbolValue);
					}
					
					public void report_fatal_error(String message, Object info) {
									report_error(message, info);
									done_parsing();
									Symbol sym = (Symbol)info;
									mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
									throw new mjparser.ParseException("Fatal parsing error", tok.line, tok.pos);
					}
					
					public void report_error(String message, Object info) {
									Symbol sym = (Symbol)info;
									mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
									System.out.println("sym null? "+(sym == null));
									System.out.println("sym.sym: "+sym.sym);
									System.err.println("tok null? "+ (tok == null));
									System.err.println("tok.lexeme: "+ tok.lexeme);
									System.err.println("[" + tok.line + "," + tok.pos + "] "); 
									System.err.println( message + " at " + tok.toString() );
					}
					
:}

terminal SymbolValue GIVENS;
terminal SymbolValue EVENTS;
terminal SymbolValue RAWTYPE;
terminal SymbolValue VARIABLE;
terminal SymbolValue DELTA_VARIABLE;
terminal SymbolValue NUMBER;
terminal SymbolValue LT;
terminal SymbolValue LTEQ;
terminal SymbolValue GT;
terminal SymbolValue GTEQ;
terminal SymbolValue SEMI;
terminal SymbolValue COMMA;
terminal SymbolValue COMMENT;
non terminal program;
non terminal vars;
non terminal var;
non terminal stmts;
non terminal stmt;
non terminal SymbolValue rawtype;
non terminal Predicate exp;
non terminal SymbolValue int;
non terminal SymbolValue variable;
non terminal comments;

precedence left LT, LTEQ, GT, GTEQ;

program	::=	
	GIVENS vars EVENTS vars
	;

vars ::=
		vars var
		| var
		;
	
var ::=
		variable:v COMMA rawtype:t
		{:
				/*
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				*/
		:}
		| variable:v COMMA rawtype:t COMMA stmts
		{:
				
		:}
		;
	
stmts   ::=
    stmts COMMA stmt
    |	stmt
				;

stmt	::=
    exp:e		{: System.out.println("exp "+ e.toString()); :}
    ;

exp ::=            
				variable:a LT:op int:b       {: System.out.println(a.toString() + " < " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d < Double.valueOf(b.lexeme);}; :}
				|	variable:a LTEQ:op int:b			{: System.out.println(a.toString() +" <= " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d <= Double.valueOf(b.lexeme);}; :}
				|	variable:a GT:op int:b			  {: System.out.println(a.toString() +" > " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d > Double.valueOf(b.lexeme);}; :}
				|	variable:a GTEQ:op int:b			{: System.out.println(a.toString() +" >= " + b.toString()); RESULT = (Predicate<Double>) (Double d) -> {return d >= Double.valueOf(b.lexeme);}; :}
				| NUMBER:n              {: RESULT = (Predicate<Double>) (Double d) -> {return Math.abs(d-Double.valueOf(n.lexeme))<1;}; :}
    ;

int ::=
	NUMBER:n	{: System.out.println("int "+n.lexeme); RESULT = n; :}
	;

variable ::=
	VARIABLE:v {: System.out.println(v.lexeme); RESULT = v; :}
	;
	
	rawtype ::=
			RAWTYPE:rt {:System.out.println("RawType "+RawType.valueOf(rt.toString())); RESULT = rt; :}
		;
