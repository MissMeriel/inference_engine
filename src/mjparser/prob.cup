/* prob.cup */
 
/***** Command Line build instructions (as implemented in Makefile)
 in this (src) directory:
 java -jar java-cup-11a.jar  PA0.cup
 javac -classpath .:java-cup-11a-runtime.jar -d . parser.java sym.java Yylex.java
    
*****/

/***** Run instructions
 in this (src) directory:
 java -classpath .:java-cup-11a-runtime.jar parser ../infile

*****/
package mjparser;

import java_cup.runtime.*;
import java.io.FileInputStream;
import java.util.function.Predicate;
import java.util.*;
import java.io.PrintWriter;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.File;
import java.io.FileNotFoundException;

import inference_engine.RawType;
import inference_engine.Global;

parser code {:
    public static void main(String args[]) throws Exception {
        new parser(new Yylex(new FileInputStream(args[0]))).parse();
    }
				
				public PrintWriter out; 
    
					public String programName;
	
					public void unrecovered_syntax_error(Symbol cur_SymbolValue) {
									//System.out.println("cur_SymbolValue: "+ cur_SymbolValue.value);
									report_fatal_error("Fatal syntax error", cur_SymbolValue);
					}
					
					public void report_fatal_error(String message, Object info) {
									report_error(message, info);
									done_parsing();
									Symbol sym = (Symbol)info;
									mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
									throw new mjparser.ParseException("Fatal parsing error", tok.line, tok.pos);
					}
					
					public void report_error(String message, Object info) {
									Symbol sym = (Symbol)info;
									mjparser.SymbolValue tok = (mjparser.SymbolValue)sym.value;
									System.out.println("sym null? "+(sym == null));
									System.out.println("sym.sym: "+sym.sym);
									System.err.println("tok null? "+ (tok == null));
									System.err.println("tok.lexeme: "+ tok.lexeme);
									System.err.println("[" + tok.line + "," + tok.pos + "] "); 
									System.err.println( message + " at " + tok.toString() );
					}
					
:}

terminal SymbolValue GIVENS;
terminal SymbolValue EVENTS;
terminal SymbolValue RAWTYPE;
terminal SymbolValue VARIABLE;
terminal SymbolValue DELTA_VARIABLE;
terminal SymbolValue THRESHOLD;
terminal SymbolValue DELTA;
terminal SymbolValue DEF;
terminal SymbolValue NUMBER;
terminal SymbolValue EQ;
terminal SymbolValue NOTEQ;
terminal SymbolValue LT;
terminal SymbolValue LTEQ;
terminal SymbolValue GT;
terminal SymbolValue GTEQ;
terminal SymbolValue LOGICAL_AND;
terminal SymbolValue LOGICAL_OR;
terminal SymbolValue SEMI;
terminal SymbolValue COMMA;
terminal SymbolValue COMMENT;
non terminal program;
non terminal ArrayList<String> vars;
non terminal String var;
non terminal BoundList stmts;
non terminal Bound stmt;
non terminal SymbolValue rawtype;
non terminal Bound exp;
non terminal SymbolValue threshold_stmt;
non terminal SymbolValue delta_stmt;
non terminal SymbolValue int;
non terminal SymbolValue variable;
non terminal comments;

precedence left LT, LTEQ, GT, GTEQ, LOGICAL_AND, LOGICAL_OR;

program	::=	
	GIVENS vars:gv EVENTS vars:ev
	{:
			/* System.out.print("Given vars: ");
			System.out.println(gv);
			System.out.print("Event vars: ");
			System.out.println(ev); */
			Global.givens = gv;
			Global.events = ev;
	:}
	;

vars ::=
		vars:vs var:v
		{: vs.add(v); RESULT = vs; :}
		|
		{: RESULT = new ArrayList<String>(); :}
		;
	
var ::=
		variable:v COMMA rawtype:t
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				//System.out.println("rt == null? "+(rt==null));
				Global.types.put(v.lexeme, rt);
				RESULT = v.lexeme;
		:}
		| variable:v COMMA rawtype:t COMMA stmts:s
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				Global.bounds.put(v.lexeme, s.tester_list);
				Global.bound_ids.put(v.lexeme, s.id_map);
				RESULT = v.lexeme;
		:}
		| variable:v COMMA rawtype:t COMMA threshold_stmt:th
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				//System.out.println("threshold_stmt "+ th.toString());
				Double dbl = Double.valueOf(th.lexeme);
				Global.thresholds.put(v.lexeme, dbl);
				RESULT = v.lexeme;
		:}
		| variable:v COMMA rawtype:t COMMA delta_stmt:d
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				//System.out.println("delta_stmt "+ d.toString());
				Double dbl = Double.valueOf(d.lexeme);
				Global.deltas.put(v.lexeme, dbl);
				RESULT = v.lexeme;
		:}
		| variable:v COMMA rawtype:t COMMA threshold_stmt:th COMMA delta_stmt:d
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				//System.out.println("delta_stmt "+ d.toString());
				Double th_dbl = Double.valueOf(th.lexeme);
				Global.thresholds.put(v.lexeme, th_dbl);
				Double delta_dbl = Double.valueOf(d.lexeme);
				Global.deltas.put(v.lexeme, delta_dbl);
				RESULT = v.lexeme;
		:}
		| variable:v COMMA rawtype:t COMMA delta_stmt:d COMMA stmts:s
		{:
				//System.out.println("Handling rawtype "+t.lexeme);
				RawType rt = RawType.valueOf(t.lexeme);
				Global.types.put(v.lexeme, rt);
				//System.out.println("delta_stmt "+ d.toString());
				Double dbl = Double.valueOf(d.lexeme);
				Global.deltas.put(v.lexeme, dbl);
				Global.bounds.put(v.lexeme, s.tester_list);
				Global.bound_ids.put(v.lexeme, s.id_map);
				RESULT = v.lexeme;
		:}
		;
	
stmts   ::=
    stmts:ss COMMA stmt:s
				{:
						ss.tester_list.add((Predicate) s.tester);
						ss.id_map.put(s.id, s.tester);
						RESULT = ss;
				:}
    |	stmt:s
				{:
						BoundList blist = new BoundList();
						blist.tester_list.add(s.tester);
						blist.id_map.put(s.id, s.tester);
						RESULT = blist;
				:}
				;

stmt	::=
    exp:e
				{:
						//System.out.println("exp "+ e.toString());
						RESULT = e;
				:}
				| exp:e LOGICAL_OR:lo stmt:s
				{:
						String id = e.id + lo.lexeme + s.id;
						System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return e.tester.test(d) || s.tester.test(d);};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
    ;


exp ::=            
				variable:a LT:op int:b
				{:
							String id = a.toString()+ "<" + b.toString();
							//System.out.println(id);
							Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return d < Double.valueOf(b.lexeme);};
							Bound bound = new Bound(id, tester);
							RESULT = bound;
				:}
				|	variable:a LTEQ:op int:b
				{:
						String id = a.toString()+"<=" + b.toString();
						//System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return d <= Double.valueOf(b.lexeme);};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
				|	variable:a GT:op int:b
				{:
						String id = a.toString() +">" + b.toString();
						//System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return d > Double.valueOf(b.lexeme);};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
				|	variable:a GTEQ:op int:b
				{:
						String id = a.toString() +">=" + b.toString();
						//System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return d >= Double.valueOf(b.lexeme);};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
				| variable:a EQ:op NUMBER:n
				{:
						String id = a.toString() + op.lexeme + n.lexeme;
						//System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return Math.abs(d-Double.valueOf(n.lexeme))<1;};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
				| variable:a NOTEQ:op NUMBER:n
				{:
						String id = a.toString() + op.lexeme + n.lexeme;
						//System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return Math.abs(d-Double.valueOf(n.lexeme))>1;};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
				| exp:e1 LOGICAL_AND:la exp:e2
				{:
						String id = e1.id + la.lexeme + e2.id;
						System.out.println(id);
						Predicate<Double> tester = (Predicate<Double>) (Double d) -> {return e1.tester.test(d) && e2.tester.test(d);};
						Bound bound = new Bound(id, tester);
						RESULT = bound;
				:}
    ;


threshold_stmt ::=
	THRESHOLD DEF int:i	{: RESULT = i; :}
	;
	
delta_stmt ::=
	DELTA DEF int:i	{: RESULT = i; :}
	;
	
int ::=
	NUMBER:n	{: /*System.out.println("int "+n.lexeme);*/ RESULT = n; :}
	;

variable ::=
	VARIABLE:v {: /*System.out.println(v.lexeme);*/ RESULT = v; :}
	;
	
rawtype ::=
		RAWTYPE:rt {: /*System.out.println("RawType "+RawType.valueOf(rt.toString()));*/ RESULT = rt; :}
	;
